# Base Python 3

## История

История языка Python начинается в 1980-х годах, когда Гвидо ван Россум, сотрудник центра математики и
информатики в Нидерландах, приступил к созданию его первой версии. И до сих пор «Гвидо ван Россум»
остается «великодушным пожизненным диктатором».

К данному моменту были выпущены уже три версии языка — Python 1, Python 2, Python 3, причем первые
две из них обратно совместимы, а Python 3 и Python 2 — уже нет. Это связано с тем, что те улучшения,
которые были сделаны в Python 3, невозможно внести без нарушения обратной совместимости. Официально
поддерживаются обе версии: Python 3 — это будущее языка, более современная версия, а Python 2 поддерживается
до сих пор из-за огромного количества наработок, которые еще не были перенесены на более свежую
версию.

Следует особо отметить, что Python выпускается под свободной лицензией «Python Software Foundation
License», разрешающей использовать исходный код проекта не только в открытом, но и в коммерческом
программном обеспечении. Python работает почти на всех известных платформах. Существуют версии для
MS Windows, Linux, Mac OS, FreeBSD и так далее.

Также привлекательной стороной Python является богатая стандартная библиотека. В нее входят, например,
модуль для работы с текстом в различных кодировках и модуль для работы с регулярными выражениями.
Кроме стандартной библиотеки, доступны: библиотека matplotlib для построения графиков функций,
pandas — для работы с электронными таблицами и scipy — для научных и инженерных расчетов.

Язык Python отличается лаконичным синтаксисом, поэтому на нем и читать чужой код, и писать свой
очень просто. Разработчики языка придерживаются философии, называемой «The Zen of Python», текст
которой на английском языке выводится интерпретатором по команде `import this`. Ниже представлена часть
текста, переведенная на русский язык:

- Красивое лучше, чем уродливое.
- Простое лучше, чем сложное.
- Читаемость имеет значение.
- Ошибки никогда не должны замалчиваться.
- Сейчас лучше, чем никогда.
- Хотя никогда зачастую лучше, чем прямо сейчас.
- Если реализацию сложно объяснить — идея плоха.
- Если реализацию легко объяснить — идея, возможно, хороша.

Python был выбран в качестве основного языка программирования для нашей специализации по многим
причинам. Вот некоторые из них:

- Python — свободное ПО.
- Python доступен практически на всех платформах.
- Python прост в изучении.
- Python можно использовать в интерактивном режиме.
- Python имеет большое сообщество пользователей и разработчиков.
- Для Python доступно огромное число библиотек. При этом богатый набор функций имеется в стандартной
библиотеке.

## Базовый синтаксис Python

Быстрое способ узнать язык - это посмотреть хорошо продокументированный код на нём.

```python
####################################################
## 1. Примитивные типы данных и операторы
####################################################

# У вас есть числа
3 #=> 3

# Математика работает вполне ожидаемо
1 + 1 #=> 2
8 - 1 #=> 7
10 * 2 #=> 20

# Кроме деления, которое по умолчанию возвращает число с плавающей запятой
35 / 5  # => 7.0

# Результат целочисленного деления округляется в меньшую сторону
# как для положительных, так и для отрицательных чисел.
5 // 3     # => 1
5.0 // 3.0 # => 1.0 # работает и для чисел с плавающей запятой
-5 // 3  # => -2
-5.0 // 3.0 # => -2.0

# Когда вы используете числа с плавающей запятой,
# результатом будет также число с плавающей запятой
3 * 2.0 # => 6.0

# Остаток от деления
7 % 3 # => 1

# Возведение в степень
2**4 # => 16

# Приоритет операций указывается скобками
(1 + 3) * 2 #=> 8

# Для логических (булевых) значений существует отдельный примитивный тип
True
False

# Для отрицания используется ключевое слово not
not True #=> False
not False #=> True

# Логические операторы
# Обратите внимание: ключевые слова «and» и «or» чувствительны к регистру букв
True and False #=> False
False or True #=> True

# Обратите внимание, что логические операторы используются и с целыми числами
0 and 2 #=> 0
-5 or 0 #=> -5
0 == False #=> True
2 == True #=> False
1 == True #=> True

# Равенство — это ==
1 == 1 #=> True
2 == 1 #=> False

# Неравенство — это !=
1 != 1 #=> False
2 != 1 #=> True

# Ещё немного сравнений
1 < 10 #=> True
1 > 10 #=> False
2 <= 2 #=> True
2 >= 2 #=> True

# Сравнения могут быть записаны цепочкой:
1 < 2 < 3 #=> True
2 < 3 < 2 #=> False

# Строки определяются символом " или '
"Это строка."
'Это тоже строка.'

# И строки тоже могут складываться! Хотя лучше не злоупотребляйте этим.
"Привет " + "мир!" #=> "Привет мир!"

# Со строкой можно работать, как со списком символов
"Это строка"[0] #=> 'Э'

# Метод format используется для форматирования строк:
"{0} могут быть {1}".format("строки", "форматированы")

# Вы можете повторять аргументы форматирования, чтобы меньше печатать.
"Ехал {0} через реку, видит {0} - в реке {1}! Сунул {0} руку в реку, {1} за руку греку цап!".format("грека", "рак")
#=> "Ехал грека через реку, видит грека - в реке рак! Сунул грека руку в реку, рак за руку греку цап!"
# Если вы не хотите считать, можете использовать ключевые слова.
"{name} хочет есть {food}".format(name="Боб", food="лазанью")

# Если ваш код на Python 3 нужно запускать также и под Python 2.5 и ниже,
# вы также можете использовать старый способ форматирования:
"%s можно %s %s способом" % ("строки", "интерполировать", "старым")

# None является объектом
None #=> None

# Не используйте оператор равенства '==' для сравнения
# объектов с None. Используйте для этого 'is'
"etc" is None #=> False
None is None  #=> True

# Оператор «is» проверяет идентичность объектов. Он не
# очень полезен при работе с примитивными типами, но
# зато просто незаменим при работе с объектами.

# None, 0 и пустые строки/списки/словари приводятся к False.
# Все остальные значения равны True
bool(0)  # => False
bool("")  # => False
bool([]) #=> False
bool({}) #=> False


####################################################
## 2. Переменные и коллекции
####################################################

# В Python есть функция Print
print("Я Python. Приятно познакомиться!")

# Объявлять переменные перед инициализацией не нужно.
# По соглашению используется нижний_регистр_с_подчёркиваниями
some_var = 5
some_var #=> 5

# При попытке доступа к неинициализированной переменной
# выбрасывается исключение.
# Об исключениях см. раздел «Поток управления и итерируемые объекты».
some_unknown_var  # Выбрасывает ошибку именования

# Списки хранят последовательности
li = []
# Можно сразу начать с заполненного списка
other_li = [4, 5, 6]

# Объекты добавляются в конец списка методом append
li.append(1)    # [1]
li.append(2)    # [1, 2]
li.append(4)    # [1, 2, 4]
li.append(3)    # [1, 2, 4, 3]
# И удаляются с конца методом pop
li.pop()        #=> возвращает 3 и li становится равен [1, 2, 4]
# Положим элемент обратно
li.append(3)    # [1, 2, 4, 3].

# Обращайтесь со списком, как с обычным массивом
li[0] #=> 1
# Обратимся к последнему элементу
li[-1] #=> 3

# Попытка выйти за границы массива приведёт к ошибке индекса
li[4] # Выдаёт IndexError

# Можно обращаться к диапазону, используя так называемые срезы
# (Для тех, кто любит математику, это называется замкнуто-открытый интервал).
li[1:3] #=> [2, 4]
# Опускаем начало
li[2:] #=> [4, 3]
# Опускаем конец
li[:3] #=> [1, 2, 4]
# Выбираем каждый второй элемент
li[::2]   # =>[1, 4]
# Переворачиваем список
li[::-1]   # => [3, 4, 2, 1]
# Используйте сочетания всего вышеназванного для выделения более сложных срезов
# li[начало:конец:шаг]

# Удаляем произвольные элементы из списка оператором del
del li[2] # [1, 2, 3]

# Вы можете складывать, или, как ещё говорят, конкатенировать списки
# Обратите внимание: значения li и other_li при этом не изменились.
li + other_li #=> [1, 2, 3, 4, 5, 6]  — Замечание: li и other_li не изменяются

# Объединять списки можно методом extend
li.extend(other_li) # Теперь li содержит [1, 2, 3, 4, 5, 6]

# Проверить элемент на вхождение в список можно оператором in
1 in li #=> True

# Длина списка вычисляется функцией len
len(li) #=> 6


# Кортежи — это такие списки, только неизменяемые
tup = (1, 2, 3)
tup[0] #=> 1
tup[0] = 3  # Выдаёт TypeError

# Всё то же самое можно делать и с кортежами
len(tup) #=> 3
tup + (4, 5, 6) #=> (1, 2, 3, 4, 5, 6)
tup[:2] #=> (1, 2)
2 in tup #=> True

# Вы можете распаковывать кортежи (или списки) в переменные
a, b, c = (1, 2, 3)     # a == 1, b == 2 и c == 3
# Кортежи создаются по умолчанию, если опущены скобки
d, e, f = 4, 5, 6
# Обратите внимание, как легко поменять местами значения двух переменных
e, d = d, e     # теперь d == 5, а e == 4


#  Словари содержат ассоциативные массивы
empty_dict = {}
# Вот так описывается предзаполненный словарь
filled_dict = {"one": 1, "two": 2, "three": 3}

# Значения извлекаются так же, как из списка, с той лишь разницей,
# что индекс — у словарей он называется ключом — не обязан быть числом
filled_dict["one"] #=> 1

# Все ключи в виде списка получаются с помощью метода keys().
# Его вызов нужно обернуть в list(), так как обратно мы получаем
# итерируемый объект, о которых поговорим позднее.
list(filled_dict.keys())   # => ["three", "two", "one"]
# Замечание: сохранение порядка ключей в словаре не гарантируется
# Ваши результаты могут не совпадать с этими.

# Все значения в виде списка можно получить с помощью values().
# И снова нам нужно обернуть вызов в list(), чтобы превратить
# итерируемый объект в список.
list(filled_dict.values())   # => [3, 2, 1]
# То же самое замечание насчёт порядка ключей справедливо и здесь

# При помощи оператора in можно проверять ключи на вхождение в словарь
"one" in filled_dict #=> True
1 in filled_dict #=> False

# Попытка получить значение по несуществующему ключу выбросит ошибку ключа
filled_dict["four"] # KeyError

# Чтобы избежать этого, используйте метод get()
filled_dict.get("one") #=> 1
filled_dict.get("four") #=> None
# Метод get также принимает аргумент по умолчанию, значение которого будет
# возвращено при отсутствии указанного ключа
filled_dict.get("one", 4) #=> 1
filled_dict.get("four", 4) #=> 4

# Метод setdefault вставляет пару ключ-значение, только если такого ключа нет
filled_dict.setdefault("five", 5) #filled_dict["five"] возвращает 5
filled_dict.setdefault("five", 6) #filled_dict["five"] по-прежнему возвращает 5

# Добавление элементов в словарь
filled_dict.update({"four":4}) #=> {"one": 1, "two": 2, "three": 3, "four": 4}
#filled_dict["four"] = 4  # Другой способ добавления элементов

# Удаляйте ключи из словаря с помощью оператора del
del filled_dict["one"]  # Удаляет ключ «one» из словаря


# Множества содержат... ну, в общем, множества
empty_set = set()
# Инициализация множества набором значений.
# Да, оно выглядит примерно как словарь… ну извините, так уж вышло.
filled_set = {1, 2, 2, 3, 4} # => {1, 2, 3, 4}

# Множеству можно назначать новую переменную
filled_set = some_set

# Добавление новых элементов в множество
filled_set.add(5) # filled_set равно {1, 2, 3, 4, 5}

# Пересечение множеств: &
other_set = {3, 4, 5, 6}
filled_set & other_set #=> {3, 4, 5}

# Объединение множеств: |
filled_set | other_set #=> {1, 2, 3, 4, 5, 6}

# Разность множеств: -
{1,2,3,4} - {2,3,5} #=> {1, 4}

# Проверка на вхождение во множество: in
2 in filled_set #=> True
10 in filled_set #=> False


####################################################
## 3. Поток управления и итерируемые объекты
####################################################

# Для начала заведём переменную
some_var = 5

# Так выглядит выражение if. Отступы в python очень важны!
# результат: «some_var меньше, чем 10»
if some_var > 10:
    print("some_var намного больше, чем 10.")
elif some_var < 10:    # Выражение elif необязательно.
    print("some_var меньше, чем 10.")
else:           # Это тоже необязательно.
    print("some_var равно 10.")


# Циклы For проходят по спискам. Результат:
    # собака — это млекопитающее
    # кошка — это млекопитающее
    # мышь — это млекопитающее
for animal in ["собака", "кошка", "мышь"]:
    # Можете использовать format() для интерполяции форматированных строк
    print("{} — это млекопитающее".format(animal))

"""
«range(число)» возвращает список чисел
от нуля до заданного числа
Результат:
    0
    1
    2
    3
"""
for i in range(4):
    print(i)

"""
Циклы while продолжаются до тех пор, пока указанное условие не станет ложным.
Результат:
    0
    1
    2
    3
"""
x = 0
while x < 4:
    print(x)
    x += 1  # Краткая запись для x = x + 1

# Используйте def для создания новых функций
def add(x, y):
    print("x равен %s, а y равен %s" % (x, y))
    return x + y    # Возвращайте результат с помощью ключевого слова return

# Вызов функции с аргументами
add(5, 6) #=> выводит «x равен 5, а y равен 6» и возвращает 11

# Другой способ вызова функции — вызов с именованными аргументами
add(y=6, x=5)   # Именованные аргументы можно указывать в любом порядке.

# Вы можете определить функцию, принимающую переменное число аргументов
def varargs(*args):
    return args

varargs(1, 2, 3) #=> (1,2,3)


# А также можете определить функцию, принимающую переменное число
# именованных аргументов
def keyword_args(**kwargs):
    return kwargs

# Вызовем эту функцию и посмотрим, что из этого получится
keyword_args(big="foot", loch="ness") #=> {"big": "foot", "loch": "ness"}

# Если хотите, можете использовать оба способа одновременно
def all_the_args(*args, **kwargs):
    print(args)
    print(kwargs)
"""
all_the_args(1, 2, a=3, b=4) выводит:
    (1, 2)
    {"a": 3, "b": 4}
"""

# Вызывая функции, можете сделать наоборот!
# Используйте символ * для распаковки кортежей и ** для распаковки словарей
args = (1, 2, 3, 4)
kwargs = {"a": 3, "b": 4}
all_the_args(*args) # эквивалентно foo(1, 2, 3, 4)
all_the_args(**kwargs) # эквивалентно foo(a=3, b=4)
all_the_args(*args, **kwargs) # эквивалентно foo(1, 2, 3, 4, a=3, b=4)
```

## Литература

1. Python StyleGuide [PEP8](https://www.python.org/dev/peps/pep-0008/). На [русском языке](http://pep8.ru/doc/pep8/).

2. [Zen of Python](https://ru.wikipedia.org/wiki/Python#.D0.A4.D0.B8.D0.BB.D0.BE.D1.81.D0.BE.D1.84.D0.B8.D1.8F).

3. [Встроенные функций в Python3](https://docs.python.org/3/library/functions.html).

4. [The Python tutorial](https://docs.python.org/3/tutorial/)
